\documentclass[]{article}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[outdir=./]{epstopdf}
\usepackage{booktabs}
\usepackage{float}
\usepackage{subcaption}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\DeclareMathOperator{\cov}{cov}

%opening
\title{SSY 230, System Identification\\
	Project 1: Estimating functions from noisy data}
\author{Yuxuan Xia\\ \href{mailto:yuxuan.xia@chalmers.se}{yuxuan.xia@chalmers.se}\\Emil Staf\\\href{mailto:emil.staf@chalmers.se}{emil.staf@chalmers.se}}

\begin{document}

\maketitle

\section{ARX estimator}
\subsection{(a) arxfit}
The \emph{arxfit} fucntion can beneficially be implemented using the Linear Regression code written in project 1. The ARX model is given by
\begin{align}
	\label{eq:ARX}
	A(q^{-1})y(t) &= B(q^{-1})u(t) + e(t) \\
	\theta &= (a_1, \ldots a_{na}, b_1, \ldots, b_{nb})^\mathsf{T}
\end{align}
according to (6.13a) in S \& S. This can be rewritten on a Linear Regression format
\begin{equation}
	\label{eq:ARX_LR}
	y(t) = \phi(t) \theta + e(t)
\end{equation}
where
\begin{equation}
	\label{eq:ARX_LR_phi}
	\phi(t) = (-y(t-1), \ldots, -y(t-na), u(t-1-nk), \ldots, u(t-1-nk-nb))^\mathsf{T}
\end{equation}
The function arxfit is implemented accordingly. It was verified against the function 
\begin{equation}
	\label{eq:system}
	y(t) = 0.2y(t-1) - 0.3y(t-2) + 0.4u(t-2) - 0.2u(t-3)
\end{equation}
without any noise, and the correct model was obtained.

\subsection{(b) id2tf}
The function \emph{id2tf} is implemented using MATLABs build in function \emph{tf(Numerator, Denominator, -1)} where \emph{Numerator} = $(\hat{b}_1, \ldots, \hat{b}_{nb})$ and \emph{Denominator} = $(1, \hat{a}_1, \ldots, \hat{a}_{na})$.

\begin{figure}[ht]
\centering
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/1b-pzmap.pdf}
	\caption{pzmap using ltiview}
	\label{fig:1b-pzmap}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/1b-step.pdf}
	\caption{Step response using ltiview}
	\label{fig:1b-step}
\end{subfigure}
\caption{MATLABs build in function \emph{ltiview} analyzing the found ARX model for the system in \eqref{eq:system} including noise.}
\label{fig:1b-ltiview}
\end{figure}

\subsection{(c) idpredict and idsimulate}
A $k$-step predictor for an ARX model can be fund by studying the following equations.
\begin{align}
	\label{eq:K-step predictor}
	\hat{y}(t|t-1) &= -a_1y(t-1) -a_2y(t-2) \ldots \\
	\hat{y}(t|t-2) &= -a_1\hat{y}(t-1|t-2) -a_2y(t-2) \ldots \\
	\hat{y}(t|t-3) &= -a_1\hat{y}(t-1|t-3) -a_2\hat{y}(t-2|t-3) \ldots 
\end{align}
It is possible to use the 1-step ahead predictor to calculate the 2-step predictor, the 1-step and 2-step predictor to calculate the 3-step predictor and so on. It is the regressor matrix $\Phi_i = [Y_i, U]$ that needs to be updated in a clever way in order to achieve fast matrix calculations which is shown below. The $U$ matrix is constant and given by

\begin{equation}
	U = \begin{bmatrix}
		u(0-n_k) & u(-1-n_k) & \ldots & u(1-n_b-n_k) \\
		u(1-n_k) & u(0-n_k) & \ldots & u(2-n_b-n_k) \\
		u(2-n_k) & u(1-n_k) & \ldots & u(3-n_b-n_k) \\
		\vdots & \vdots & \vdots & \vdots \\
		u(n-1-n_k) & u(n-2-n_k) & \ldots & u(n-n_b-n_k) \\
	\end{bmatrix}
\end{equation}
while
\begin{equation}
	Y_1 = \begin{bmatrix}
		y(0) & y(-1) & \ldots & y(1-n_a) \\
		y(1) & y(0) &\ldots & y(2-n_a) \\
		y(2) & y(1) &\ldots & y(3-n_a) \\
		\vdots & \vdots & \vdots & \vdots \\
		y(n-1) & y(n-2) & \ldots & y(n-n_a) \\
	\end{bmatrix}
\end{equation}
\begin{equation}
	Y_2 = \begin{bmatrix}
		\hat{y}(0|-1) & y(-1) & \ldots & y(1-n_a) \\
		\hat{y}(1|0) & y(0) &\ldots & y(2-n_a) \\
		\hat{y}(2|1) & y(1) &\ldots & y(3-n_a) \\
		\vdots & \vdots & \vdots & \vdots \\
		\hat{y}(n-1|n-2) & y(n-2) & \ldots & y(n-n_a) \\
	\end{bmatrix}
\end{equation}
\begin{equation}
Y_3 = \begin{bmatrix}
		\hat{y}(0|-2) & \hat{y}(-1|-2) & \ldots & y(1-n_a) \\
		\hat{y}(1|-1) & \hat{y}(0|-1) &\ldots & y(2-n_a) \\
		\hat{y}(2|0) & \hat{y}(1|0) &\ldots & y(3-n_a) \\
		\vdots & \vdots & \vdots & \vdots \\
		\hat{y}(n-1|n-3) & \hat{y}(n-2|n-1) & \ldots & y(n-n_a) \\
	\end{bmatrix}
\end{equation}
where $\hat{y}(t|t-k) = \Phi_k \hat{\theta}$ and the values for both $y$ and $u$ prior to $t=1$ are initialized to zero.

Simulation can be performed by setting $k > n$, i.e. the predictor is forced not to use any of the measured outputs. 

\subsection{(d) idcompare}
Some results for the same system as before \eqref{eq:system} are compared using \emph{idcompare} in Figure \ref{fig:1d}.
\begin{figure}[ht]
\centering
\begin{subfigure}{.30\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.3]{figures/1d-horizon_1.pdf}
	\caption{Horizon 1}
	\label{fig:1d-horizon1}
\end{subfigure}
\begin{subfigure}{.30\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.3]{figures/1d-horizon_5.pdf}
	\caption{Horizon 5}
	\label{fig:1d-horizon5}
\end{subfigure}
\begin{subfigure}{.30\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.3]{figures/1d-horizon_10.pdf}
	\caption{Horizon 10}
	\label{fig:1d-horizon10}
\end{subfigure}
\caption{Some results using the implemented \emph{idcompare} function. It is clear that the model uncertainty is increasing for increasing horizons, which means that less data is allowed in the prediction step. The mse on validation data is also increasing as the horizon is increasing.}
\label{fig:1d}
\end{figure}

\section{OE estimator}

\subsection{(a) oefit}
Need to include explanation of why it is ok to use arxfit to and filter to obtain OE model!

\subsection{(b) id2tf}
No changes from ARX.

\subsection{(c) idpredict}
According to the lecture notes a $k$-step predictor can be written on the form
\begin{equation}
	\label{eq:K-step Prediction}
	\hat{y}(t|t-k) = \bar{H}_k(q)H^{-1}(q)G(q)u(t) + (1-\bar{H}_k(q)H^{-1}(q))y(t)
\end{equation}
which for an OE-model simplifies to
\begin{equation}
	\label{eq:K-step Prediction OE}
	\hat{y}(t|t-k) = G(q)u(t)
\end{equation}
since $H^{-1}(q)=1$ and $\bar{H}_k^{-1}(q)=1$ for all $k > 1$. Therefore prediction is the same as simulation for the OE-model and the \emph{idpredict} function calls the \emph{idsimulate} function in the case of an OE-model.

\subsection{(d) idsimulate}
Using the MATLAB build in function \emph{lsim} after creating the OE transfer function by calling \emph{id2tf}.

\subsection{(e) idcompare}
No changes necessary? 

Showing only the prediction since simulation is the same as stated above. This can be seen in the Figure \ref{fig:2e-validation}, where OE-data was created and an ARX-model is compared to an OE-model.

\begin{figure}[ht]
\centering
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/2e-OE-horizon_1.pdf}
	\caption{OE-model}
	\label{fig:2e-OE-horizon_1}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/2e-ARX-horizon_1.pdf}
	\caption{ARX-model}
	\label{fig:2e-ARX-horizon_1}
\end{subfigure}
\caption{OE-model vs ARX-model on OE system of order nb = 2, nf = 2, nk = 1.}
\label{fig:2e-validation<}
\end{figure}
As can be seen in Figure \ref{fig:2e-validation} the model uncertainty is substantially smaller for the OE-model in comparison to the ARX model.

\section{Identify two systems}

\begin{figure}[ht]
\centering
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-ARX-Ex1-idcompare.pdf}
	\caption{ARX}
	\label{fig:Ex1-idcompare-ARX}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-OE-Ex1-idcompare.pdf}
	\caption{OE}
	\label{fig:Ex1-idcompare-OE}
\end{subfigure}
\caption{Dataset exercise1}
\label{fig:Ex1-idcompare}
\end{figure}

\begin{figure}[ht]
\centering
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-ARX-Ex1.pdf}
	\caption{ARX}
	\label{fig:Ex1-ARX}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-OE-Ex1.pdf}
	\caption{OE}
	\label{fig:Ex1-OE}
\end{subfigure}
\caption{Dataset exercise1, using build-in MATLAB plotting functionality.}
\label{fig:Ex1}
\end{figure}


\begin{figure}[ht]
\centering
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-ARX-Ex2-idcompare.pdf}
	\caption{ARX}
	\label{fig:Ex2-idcompare-ARX}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-OE-Ex2-idcompare.pdf}
	\caption{OE}
	\label{fig:Ex2-idcompare-OE}
\end{subfigure}
\caption{Dataset exercise2}
\label{fig:Ex2-idcompare}
\end{figure}

\begin{figure}[ht]
\centering
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-ARX-Ex2.pdf}
	\caption{ARX}
	\label{fig:Ex2-ARX}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
	\centering
	\includegraphics[trim= 10cm 8cm 10cm 8cm, scale=0.4]{figures/3-OE-Ex2.pdf}
	\caption{OE}
	\label{fig:Ex2-OE}
\end{subfigure}
\caption{Dataset exercise2, using build-in MATLAB plotting functionality.}
\label{fig:Ex2}
\end{figure}

\end{document}
